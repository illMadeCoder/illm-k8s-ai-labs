## Appendix M: SLSA Framework Deep Dive

*Understanding Supply-chain Levels for Software Artifacts (SLSA) from theory to implementation. This appendix explores all four SLSA levels, their security guarantees, and when each level is appropriate.*

### M.1 SLSA Overview

**Goal:** Understand the SLSA framework and its security model

**Learning objectives:**
- Understand what threats SLSA addresses
- Differentiate between SLSA levels
- Evaluate which level is appropriate for different contexts

**Concepts:**

SLSA answers: "Can I trust this artifact came from where it claims?"

**The Supply Chain Threat Model:**
```
Source Code → Build System → Artifact → Registry → Deployment
     ↑              ↑            ↑          ↑           ↑
  Compromise    Compromise   Tamper     Tamper    Substitute
   source        build       output     stored     at deploy
```

**What SLSA Provides:**
- Provenance: Metadata about how an artifact was built
- Attestations: Signed statements about the artifact
- Verification: Ability to validate provenance claims

---

### M.2 SLSA Level 1: Provenance Exists

**Goal:** Establish basic build provenance

**Security guarantee:** Build process is documented

**Requirements:**
- [ ] Build process exists and is scripted
- [ ] Provenance is generated (any format)
- [ ] Provenance describes the build (inputs, outputs, builder)

**What Level 1 proves:**
- Someone wrote down how this was built
- There's a record of the build

**What Level 1 does NOT prove:**
- The provenance is accurate
- The provenance wasn't forged
- The build actually followed the described process

**Example:**
```yaml
# Just having a CI workflow = Level 1
name: Build
on: [push]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - run: docker build -t myapp .
      - run: echo "Built from $GITHUB_SHA" > provenance.txt
```

**When Level 1 is appropriate:**
- Internal tools with trusted developers
- Early development before formal release
- When you need a starting point

---

### M.3 SLSA Level 2: Signed Provenance

**Goal:** Provenance is authentic and tamper-evident

**Security guarantee:** Provenance is signed by a trusted service

**Requirements:**
- [ ] All Level 1 requirements
- [ ] Provenance is signed by the build service
- [ ] Provenance is generated by the build service (not user-controlled scripts)
- [ ] Provenance format follows a specification (e.g., in-toto)

**What Level 2 proves:**
- Provenance was generated by a specific build service
- Provenance hasn't been modified after generation
- Build service vouches for the provenance content

**What Level 2 does NOT prove:**
- User-controlled code didn't influence provenance
- Build environment was isolated/hardened

**Implementation approaches:**

```yaml
# Approach A: GitHub native attestations (SLSA 2)
- uses: actions/attest-build-provenance@v2
  with:
    subject-name: ghcr.io/owner/app
    subject-digest: ${{ steps.build.outputs.digest }}

# Approach B: Cosign keyless (equivalent security, different format)
- run: cosign sign --yes $IMAGE@$DIGEST
# OIDC token signed by GitHub, recorded in Rekor
```

**Cosign Keyless vs SLSA 2 comparison:**

| Aspect | Cosign Keyless | SLSA 2 Attestations |
|--------|----------------|---------------------|
| Provenance source | OIDC token from GitHub | Build service attestation |
| Signing | Fulcio certificate | GitHub attestation signing |
| Transparency log | Rekor | GitHub attestation storage |
| Format | Sigstore-specific | in-toto/SLSA specification |
| Non-falsifiable | ✅ GitHub controls OIDC | ✅ GitHub controls attestation |

**Key insight:** Cosign keyless signing with Rekor provides equivalent non-falsifiability to SLSA 2 because GitHub controls the OIDC token issuance. The difference is standardization and metadata richness.

**When Level 2 is appropriate:**
- Most production workloads
- When you need auditable provenance
- Compliance requires signed provenance

---

### M.4 SLSA Level 3: Hardened Build

**Goal:** Provenance is generated by an isolated, hardened builder

**Security guarantee:** Even if user code is malicious, provenance is accurate

**Requirements:**
- [ ] All Level 2 requirements
- [ ] Build runs on isolated infrastructure
- [ ] Provenance generated by isolated builder (not user workflow)
- [ ] User-controlled code cannot influence provenance generation
- [ ] Build service has hardening measures

**What Level 3 proves:**
- Provenance was generated outside of user-controlled code
- User's CI script cannot fake provenance claims
- Build environment protects provenance integrity

**What Level 3 does NOT prove:**
- Source code is safe or reviewed
- Dependencies are trustworthy
- The build definition wasn't maliciously modified

**Implementation:**

```yaml
# SLSA 3 requires the slsa-github-generator reusable workflow
jobs:
  build:
    outputs:
      digest: ${{ steps.build.outputs.digest }}
    steps:
      - uses: docker/build-push-action@v6
        id: build

  # Separate job - isolated provenance generation
  provenance:
    needs: build
    permissions:
      id-token: write
      packages: write
    uses: slsa-framework/slsa-github-generator/.github/workflows/generator_container_slsa3.yml@v2.0.0
    with:
      image: ghcr.io/owner/app
      digest: ${{ needs.build.outputs.digest }}
```

**Why it's isolated:**
- `slsa-github-generator` is a reusable workflow you don't control
- Runs in a separate job with its own permissions
- Generates provenance based on actual GitHub context
- Signed with the generator's identity, not your workflow's

**Limitation: Matrix builds:**
```yaml
# This DOES NOT work - reusable workflows can't be called in matrix
jobs:
  build:
    strategy:
      matrix:
        app: [app1, app2, app3]

  provenance:
    uses: slsa-github-generator/...  # Can't iterate over matrix
```

**Workarounds:**
- Separate workflow per app (doesn't scale)
- SLSA 3 for releases only (tagged builds)
- Dynamic workflow generation (complex)

**When Level 3 is appropriate:**
- Public releases with external consumers
- Compliance explicitly requires "SLSA Level 3"
- High-value artifacts (base images, shared libraries)
- When you want defense against CI compromise

---

### M.5 SLSA Level 4: Verified Build

**Goal:** Two-person review and hermetic builds

**Security guarantee:** No single person can push malicious code undetected

**Requirements:**
- [ ] All Level 3 requirements
- [ ] Two-person review of all changes
- [ ] Hermetic builds (no network access, all deps pinned)
- [ ] Reproducible builds (same input → same output)

**What Level 4 proves:**
- At least two people approved every change
- Build is fully deterministic
- No hidden inputs can influence the build

**What Level 4 does NOT prove:**
- Both reviewers aren't colluding
- The code is correct or secure

**Implementation requirements:**

```yaml
# Branch protection (two-person review)
# GitHub Settings → Branches → Branch protection rules
- Required reviewers: 2
- Dismiss stale reviews: true
- Require review from code owners: true

# Hermetic build (no network during build)
# Requires all dependencies vendored/cached
jobs:
  build:
    runs-on: ubuntu-latest
    container:
      image: builder:hermetic
      options: --network none  # No network access
    steps:
      - run: build --offline  # All deps pre-fetched
```

**Reproducible builds:**
```dockerfile
# All inputs must be pinned
FROM golang:1.22.0@sha256:abc123...  # Pinned by digest
RUN go build -trimpath -ldflags="-buildid="  # Reproducible flags
```

**Challenges:**
- Hermetic builds are hard (network, timestamps, randomness)
- Reproducibility requires toolchain cooperation
- Two-person review slows velocity

**When Level 4 is appropriate:**
- Critical infrastructure (OS, compilers, core libraries)
- Compliance requires SLSA 4 (rare)
- Nation-state threat model
- When absolute trust is required

---

### M.6 SLSA Level Comparison

| Level | Provenance | Signed | Isolated | Two-Person | Hermetic |
|-------|------------|--------|----------|------------|----------|
| 1 | ✅ | ❌ | ❌ | ❌ | ❌ |
| 2 | ✅ | ✅ | ❌ | ❌ | ❌ |
| 3 | ✅ | ✅ | ✅ | ❌ | ❌ |
| 4 | ✅ | ✅ | ✅ | ✅ | ✅ |

**Threat coverage by level:**

| Attack | L1 | L2 | L3 | L4 |
|--------|----|----|----|----|
| Build process undocumented | ✅ | ✅ | ✅ | ✅ |
| Provenance forged after build | ❌ | ✅ | ✅ | ✅ |
| Malicious CI script fakes provenance | ❌ | ❌ | ✅ | ✅ |
| Single malicious developer | ❌ | ❌ | ❌ | ✅ |
| Non-deterministic build injection | ❌ | ❌ | ❌ | ✅ |

---

### M.7 This Lab's Implementation

**Current state: SLSA Level 2 with Cosign keyless**

```
Build → SLSA 2 Attestation → Cosign Sign → SBOM → Trivy → GHCR
              ↓                    ↓
       actions/attest-        Rekor log
       build-provenance       (immutable)
```

**Why not Level 3:**
- Matrix builds (auto-detection) incompatible with slsa-github-generator
- Cosign + Rekor already provides non-falsifiable provenance
- Lab context doesn't require formal SLSA 3 compliance

**Equivalent security properties:**
- Provenance signed by GitHub-controlled OIDC
- Immutable transparency log (Rekor)
- Cannot forge provenance after the fact

**Path to Level 3 (if needed):**
- Add release workflow for tagged versions
- Use slsa-github-generator for release builds
- Keep matrix workflow for continuous deployment

---

### M.8 Verification Commands

**Verify SLSA 2 provenance (GitHub attestations):**
```bash
gh attestation verify ghcr.io/owner/app:tag --owner owner
```

**Verify Cosign signature:**
```bash
cosign verify \
  --certificate-oidc-issuer="https://token.actions.githubusercontent.com" \
  --certificate-identity-regexp="github.com/owner/repo" \
  ghcr.io/owner/app:tag
```

**Verify SLSA 3 provenance:**
```bash
slsa-verifier verify-image ghcr.io/owner/app:tag \
  --source-uri github.com/owner/repo \
  --source-tag v1.0.0
```

**Inspect provenance content:**
```bash
# SLSA attestation
cosign download attestation ghcr.io/owner/app:tag | jq '.payload | @base64d | fromjson'

# Rekor entry
rekor-cli get --uuid <entry-uuid> --format json
```

---

### M.9 References

- [SLSA Specification](https://slsa.dev/spec/v1.0/)
- [SLSA GitHub Generator](https://github.com/slsa-framework/slsa-github-generator)
- [GitHub Artifact Attestations](https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds)
- [Sigstore Documentation](https://docs.sigstore.dev/)
- [in-toto Specification](https://in-toto.io/)
- [Reproducible Builds](https://reproducible-builds.org/)
